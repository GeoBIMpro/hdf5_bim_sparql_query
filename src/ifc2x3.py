import os
import sys
import pickle

schema_fn = os.path.join(os.path.dirname(__file__), "IFC2X3_TC1.exp")
cache_file = schema_fn + ".cache.dat"
if os.path.exists(cache_file):
    with open(cache_file, "rb") as f:
        schema = pickle.load(f)
else:
    from pyparsing import *
    from nodes import *
    
    import schema
    
    ABS = (CaselessKeyword("abs"))
    ABSTRACT = (CaselessKeyword("abstract"))
    ACOS = (CaselessKeyword("acos"))
    AGGREGATE = (CaselessKeyword("aggregate"))
    ALIAS = (CaselessKeyword("alias"))
    AND = (CaselessKeyword("and"))
    ANDOR = (CaselessKeyword("andor"))
    ARRAY = (CaselessKeyword("array"))
    AS = (CaselessKeyword("as"))
    ASIN = (CaselessKeyword("asin"))
    ATAN = (CaselessKeyword("atan"))
    BAG = (CaselessKeyword("bag"))
    BASED_ON = (CaselessKeyword("based_on"))
    BEGIN = (CaselessKeyword("begin"))
    BINARY = (CaselessKeyword("binary"))
    BLENGTH = (CaselessKeyword("blength"))
    BOOLEAN = (CaselessKeyword("boolean"))
    BY = (CaselessKeyword("by"))
    CASE = (CaselessKeyword("case"))
    CONSTANT = (CaselessKeyword("constant"))
    CONST_E = (CaselessKeyword("const_e"))
    COS = (CaselessKeyword("cos"))
    DERIVE = (CaselessKeyword("derive"))
    DIV = (CaselessKeyword("div"))
    ELSE = (CaselessKeyword("else"))
    END = (CaselessKeyword("end"))
    END_ALIAS = (CaselessKeyword("end_alias"))
    END_CASE = (CaselessKeyword("end_case"))
    END_CONSTANT = (CaselessKeyword("end_constant"))
    END_ENTITY = (CaselessKeyword("end_entity"))
    END_FUNCTION = (CaselessKeyword("end_function"))
    END_IF = (CaselessKeyword("end_if"))
    END_LOCAL = (CaselessKeyword("end_local"))
    END_PROCEDURE = (CaselessKeyword("end_procedure"))
    END_REPEAT = (CaselessKeyword("end_repeat"))
    END_RULE = (CaselessKeyword("end_rule"))
    END_SCHEMA = (CaselessKeyword("end_schema"))
    END_SUBTYPE_CONSTRAINT = (CaselessKeyword("end_subtype_constraint"))
    END_TYPE = (CaselessKeyword("end_type"))
    ENTITY = (CaselessKeyword("entity"))
    ENUMERATION = (CaselessKeyword("enumeration"))
    ESCAPE = (CaselessKeyword("escape"))
    EXISTS = (CaselessKeyword("exists"))
    EXTENSIBLE = (CaselessKeyword("extensible"))
    EXP = (CaselessKeyword("exp"))
    FALSE = (CaselessKeyword("false"))
    FIXED = (CaselessKeyword("fixed"))
    FOR = (CaselessKeyword("for"))
    FORMAT = (CaselessKeyword("format"))
    FROM = (CaselessKeyword("from"))
    FUNCTION = (CaselessKeyword("function"))
    GENERIC = (CaselessKeyword("generic"))
    GENERIC_ENTITY = (CaselessKeyword("generic_entity"))
    HIBOUND = (CaselessKeyword("hibound"))
    HIINDEX = (CaselessKeyword("hiindex"))
    IF = (CaselessKeyword("if"))
    IN = (CaselessKeyword("in"))
    INSERT = (CaselessKeyword("insert"))
    INTEGER = (CaselessKeyword("integer"))
    INVERSE = (CaselessKeyword("inverse"))
    LENGTH = (CaselessKeyword("length"))
    LIKE = (CaselessKeyword("like"))
    LIST = (CaselessKeyword("list"))
    LOBOUND = (CaselessKeyword("lobound"))
    LOCAL = (CaselessKeyword("local"))
    LOG = (CaselessKeyword("log"))
    LOG10 = (CaselessKeyword("log10"))
    LOG2 = (CaselessKeyword("log2"))
    LOGICAL = (CaselessKeyword("logical"))
    LOINDEX = (CaselessKeyword("loindex"))
    MOD = (CaselessKeyword("mod"))
    NOT = (CaselessKeyword("not"))
    NUMBER = (CaselessKeyword("number"))
    NVL = (CaselessKeyword("nvl"))
    ODD = (CaselessKeyword("odd"))
    OF = (CaselessKeyword("of"))
    ONEOF = (CaselessKeyword("oneof"))
    OPTIONAL = (CaselessKeyword("optional"))
    OR = (CaselessKeyword("or"))
    OTHERWISE = (CaselessKeyword("otherwise"))
    PI = (CaselessKeyword("pi"))
    PROCEDURE = (CaselessKeyword("procedure"))
    QUERY = (CaselessKeyword("query"))
    REAL = (CaselessKeyword("real"))
    REFERENCE = (CaselessKeyword("reference"))
    REMOVE = (CaselessKeyword("remove"))
    RENAMED = (CaselessKeyword("renamed"))
    REPEAT = (CaselessKeyword("repeat"))
    RETURN = (CaselessKeyword("return"))
    ROLESOF = (CaselessKeyword("rolesof"))
    RULE = (CaselessKeyword("rule"))
    SCHEMA = (CaselessKeyword("schema"))
    SELECT = (CaselessKeyword("select"))
    SELF = (CaselessKeyword("self"))
    SET = (CaselessKeyword("set"))
    SIN = (CaselessKeyword("sin"))
    SIZEOF = (CaselessKeyword("sizeof"))
    SKIP = (CaselessKeyword("skip"))
    SQRT = (CaselessKeyword("sqrt"))
    STRING = (CaselessKeyword("string"))
    SUBTYPE = (CaselessKeyword("subtype"))
    SUBTYPE_CONSTRAINT = (CaselessKeyword("subtype_constraint"))
    SUPERTYPE = (CaselessKeyword("supertype"))
    TAN = (CaselessKeyword("tan"))
    THEN = (CaselessKeyword("then"))
    TO = (CaselessKeyword("to"))
    TOTAL_OVER = (CaselessKeyword("total_over"))
    TRUE = (CaselessKeyword("true"))
    TYPE = (CaselessKeyword("type"))
    TYPEOF = (CaselessKeyword("typeof"))
    UNIQUE = (CaselessKeyword("unique"))
    UNKNOWN = (CaselessKeyword("unknown"))
    UNTIL = (CaselessKeyword("until"))
    USE = (CaselessKeyword("use"))
    USEDIN = (CaselessKeyword("usedin"))
    VALUE = (CaselessKeyword("value"))
    VALUE_IN = (CaselessKeyword("value_in"))
    VALUE_UNIQUE = (CaselessKeyword("value_unique"))
    VAR = (CaselessKeyword("var"))
    WHERE = (CaselessKeyword("where"))
    WHILE = (CaselessKeyword("while"))
    WITH = (CaselessKeyword("with"))
    XOR = (CaselessKeyword("xor"))
    bit = ((CaselessLiteral("0") | CaselessLiteral("1")))
    digit = ((CaselessLiteral("0") | CaselessLiteral("1") | CaselessLiteral("2") | CaselessLiteral("3") | CaselessLiteral("4") | CaselessLiteral("5") | CaselessLiteral("6") | CaselessLiteral("7") | CaselessLiteral("8") | CaselessLiteral("9")))
    digits = ((digit + ZeroOrMore(digit)))
    hex_digit = ((digit | CaselessLiteral("a") | CaselessLiteral("b") | CaselessLiteral("c") | CaselessLiteral("d") | CaselessLiteral("e") | CaselessLiteral("f")))
    letter = ((CaselessLiteral("a") | CaselessLiteral("b") | CaselessLiteral("c") | CaselessLiteral("d") | CaselessLiteral("e") | CaselessLiteral("f") | CaselessLiteral("g") | CaselessLiteral("h") | CaselessLiteral("i") | CaselessLiteral("j") | CaselessLiteral("k") | CaselessLiteral("l") | CaselessLiteral("m") | CaselessLiteral("n") | CaselessLiteral("o") | CaselessLiteral("p") | CaselessLiteral("q") | CaselessLiteral("r") | CaselessLiteral("s") | CaselessLiteral("t") | CaselessLiteral("u") | CaselessLiteral("v") | CaselessLiteral("w") | CaselessLiteral("x") | CaselessLiteral("y") | CaselessLiteral("z")))
    not_paren_star_quote_special = ((CaselessLiteral("!") | CaselessLiteral("#") | CaselessLiteral("$") | CaselessLiteral("%") | CaselessLiteral("&") | CaselessLiteral("+") | CaselessLiteral(",") | CaselessLiteral("-") | CaselessLiteral(".") | CaselessLiteral("/") | CaselessLiteral(":") | CaselessLiteral(";") | CaselessLiteral("<") | CaselessLiteral("=") | CaselessLiteral(">") | CaselessLiteral("?") | CaselessLiteral("@") | CaselessLiteral("[") | CaselessLiteral("\\") | CaselessLiteral("]") | CaselessLiteral("^") | CaselessLiteral("_") | CaselessLiteral("{") | CaselessLiteral("|") | CaselessLiteral("}") | CaselessLiteral("~")))
    not_paren_star_special = ((not_paren_star_quote_special | CaselessLiteral("\"\"")))
    not_quote = ((not_paren_star_quote_special | letter | digit | CaselessLiteral("(") | CaselessLiteral(")") | CaselessLiteral("*")))
    octet = ((hex_digit + hex_digit))
    special = ((not_paren_star_quote_special | CaselessLiteral("(") | CaselessLiteral(")") | CaselessLiteral("*") | CaselessLiteral("\"\"")))
    binary_literal = ((CaselessLiteral("%") + bit + ZeroOrMore(bit)))
    integer_literal = (digits)
    simple_id = originalTextFor(Combine((letter + ZeroOrMore((letter | digit | CaselessLiteral("_"))))))
    simple_string_literal = ((CaselessLiteral("'") + ZeroOrMore(((CaselessLiteral("'") + CaselessLiteral("'")) | not_quote)) + CaselessLiteral("'")))
    abstract_entity_declaration = (ABSTRACT)
    abstract_supertype = ((ABSTRACT + SUPERTYPE + CaselessLiteral(";")))
    add_like_op = ((CaselessLiteral("+") | CaselessLiteral("-") | OR | XOR))
    attribute_id = (simple_id)
    boolean_type = (BOOLEAN)
    built_in_constant = ((CONST_E | PI | SELF | CaselessLiteral("?")))
    built_in_function = ((ABS | ACOS | ASIN | ATAN | BLENGTH | COS | EXISTS | EXP | FORMAT | HIBOUND | HIINDEX | LENGTH | LOBOUND | LOINDEX | LOG | LOG2 | LOG10 | NVL | ODD | ROLESOF | SIN | SIZEOF | SQRT | TAN | TYPEOF | USEDIN | VALUE | VALUE_IN | VALUE_UNIQUE))
    built_in_procedure = ((INSERT | REMOVE))
    constant_id = (simple_id)
    entity_id = (simple_id)
    enumeration_id = (simple_id)
    enumeration_items = ((CaselessLiteral("(") + enumeration_id + ZeroOrMore((CaselessLiteral(",") + enumeration_id)) + CaselessLiteral(")")))
    escape_stmt = ((ESCAPE + CaselessLiteral(";")))
    function_id = (simple_id)
    integer_type = (INTEGER)
    interval_op = ((CaselessLiteral("<=") | CaselessLiteral("<")))
    logical_literal = ((FALSE | TRUE | UNKNOWN))
    logical_type = (LOGICAL)
    multiplication_like_op = ((CaselessLiteral("*") | CaselessLiteral("/") | DIV | MOD | AND | CaselessLiteral("||")))
    null_stmt = (CaselessLiteral(";"))
    number_type = (NUMBER)
    parameter_id = (simple_id)
    procedure_id = (simple_id)
    rel_op = ((CaselessLiteral("<=") | CaselessLiteral(">=") | CaselessLiteral("<>") | CaselessLiteral("=") | CaselessLiteral(":<>:") | CaselessLiteral(":=:") | CaselessLiteral("<") | CaselessLiteral(">")))
    rel_op_extended = ((rel_op | IN | LIKE))
    rule_id = (simple_id)
    rule_label_id = (simple_id)
    schema_id = (simple_id)
    sign = ((CaselessLiteral("+") | CaselessLiteral("-")))
    skip_stmt = ((SKIP + CaselessLiteral(";")))
    subtype_constraint_id = (simple_id)
    type_id = (simple_id)
    type_label_id = (simple_id)
    unary_op = ((CaselessLiteral("+") | CaselessLiteral("-") | NOT))
    variable_id = (simple_id)
    encoded_character = ((octet + octet + octet + octet))
    not_paren_star = ((letter | digit | not_paren_star_special))
    not_rparen_star = ((not_paren_star | CaselessLiteral("(")))
    not_rparen_star_then_rparen = ((not_rparen_star + ZeroOrMore(not_rparen_star) + CaselessLiteral(")") + ZeroOrMore(CaselessLiteral(")"))))
    encoded_string_literal = ((CaselessLiteral("\"") + encoded_character + ZeroOrMore(encoded_character) + CaselessLiteral("\"")))
    real_literal = (((digits + CaselessLiteral(".") + Optional(digits) + Optional((CaselessLiteral("e") + Optional(sign) + digits))) | integer_literal))
    attribute_ref = (attribute_id)
    constant_ref = (constant_id)
    entity_ref = (entity_id)
    enumeration_ref = (enumeration_id)
    function_ref = (function_id)
    parameter_ref = (parameter_id)
    procedure_ref = (procedure_id)
    rule_label_ref = (rule_label_id)
    rule_ref = (rule_id)
    schema_ref = (schema_id)
    subtype_constraint_ref = (subtype_constraint_id)
    type_label_ref = (type_label_id)
    type_ref = (type_id)
    variable_ref = (variable_id)
    attribute_qualifier = ((CaselessLiteral(".") + attribute_ref))
    constant_factor = ((built_in_constant | constant_ref))
    enumeration_extension = ((BASED_ON + type_ref + Optional((WITH + enumeration_items))))
    enumeration_reference = ((Optional((type_ref + CaselessLiteral("."))) + enumeration_ref))
    enumeration_type = ((Optional(EXTENSIBLE) + ENUMERATION + Optional(((OF + enumeration_items) | enumeration_extension)))).setParseAction(lambda t: EnumerationType(t))
    general_ref = ((parameter_ref | variable_ref))
    group_qualifier = ((CaselessLiteral("\\") + entity_ref))
    named_types = ((entity_ref | type_ref))
    named_type_or_rename = ((named_types + Optional((AS + (entity_id | type_id)))))
    population = (entity_ref)
    qualified_attribute = ((SELF + group_qualifier + attribute_qualifier))
    redeclared_attribute = ((qualified_attribute + Optional((RENAMED + attribute_id))))
    referenced_attribute = ((attribute_ref | qualified_attribute))
    rename_id = ((constant_id | entity_id | function_id | procedure_id | type_id))
    resource_ref = ((constant_ref | entity_ref | function_ref | procedure_ref | type_ref))
    rule_head = ((RULE + rule_id + FOR + CaselessLiteral("(") + entity_ref + ZeroOrMore((CaselessLiteral(",") + entity_ref)) + CaselessLiteral(")") + CaselessLiteral(";")))
    select_list = ((CaselessLiteral("(") + named_types + ZeroOrMore((CaselessLiteral(",") + named_types)) + CaselessLiteral(")")))
    string_literal = ((simple_string_literal | encoded_string_literal))
    subtype_constraint_head = ((SUBTYPE_CONSTRAINT + subtype_constraint_id + FOR + entity_ref + CaselessLiteral(";")))
    subtype_declaration = ((SUBTYPE + OF + CaselessLiteral("(") + entity_ref + ZeroOrMore((CaselessLiteral(",") + entity_ref)) + CaselessLiteral(")"))).setParseAction(lambda t: SubTypeExpression(t))
    total_over = ((TOTAL_OVER + CaselessLiteral("(") + entity_ref + ZeroOrMore((CaselessLiteral(",") + entity_ref)) + CaselessLiteral(")") + CaselessLiteral(";")))
    type_label = ((type_label_id | type_label_ref))
    unique_rule = ((rule_label_id + CaselessLiteral(":") + referenced_attribute + ZeroOrMore((CaselessLiteral(",") + referenced_attribute))))
    use_clause = ((USE + FROM + schema_ref + Optional((CaselessLiteral("(") + named_type_or_rename + ZeroOrMore((CaselessLiteral(",") + named_type_or_rename)) + CaselessLiteral(")"))) + CaselessLiteral(";")))
    not_lparen_star = ((not_paren_star | CaselessLiteral(")")))
    remark_ref = ((attribute_ref | constant_ref | entity_ref | enumeration_ref | function_ref | parameter_ref | procedure_ref | rule_label_ref | rule_ref | schema_ref | subtype_constraint_ref | type_label_ref | type_ref | variable_ref))
    attribute_decl = ((redeclared_attribute | attribute_id))
    generic_entity_type = ((GENERIC_ENTITY + Optional((CaselessLiteral(":") + type_label))))
    generic_type = ((GENERIC + Optional((CaselessLiteral(":") + type_label))))
    literal = ((binary_literal | logical_literal | real_literal | string_literal))
    resource_or_rename = ((resource_ref + Optional((AS + rename_id))))
    schema_version_id = (string_literal)
    select_extension = ((BASED_ON + type_ref + Optional((WITH + select_list))))
    select_type = ((Optional((EXTENSIBLE + Optional(GENERIC_ENTITY))) + SELECT + Optional((select_list | select_extension)))).setParseAction(lambda t: SelectType(t))
    unique_clause = ((UNIQUE + unique_rule + CaselessLiteral(";") + ZeroOrMore((unique_rule + CaselessLiteral(";")))))
    lparen_then_not_lparen_star = ((CaselessLiteral("(") + ZeroOrMore(CaselessLiteral("(")) + not_lparen_star + ZeroOrMore(not_lparen_star)))
    remark_tag = ((CaselessLiteral("\"") + remark_ref + ZeroOrMore((CaselessLiteral(".") + remark_ref)) + CaselessLiteral("\"")))
    tail_remark = ((CaselessLiteral("--") + Optional(remark_tag)))
    constructed_types = ((enumeration_type | select_type))
    reference_clause = ((REFERENCE + FROM + schema_ref + Optional((CaselessLiteral("(") + resource_or_rename + ZeroOrMore((CaselessLiteral(",") + resource_or_rename)) + CaselessLiteral(")"))) + CaselessLiteral(";")))
    interface_specification = ((reference_clause | use_clause))
    procedure_decl = Forward()
    bag_type = Forward()
    general_bag_type = Forward()
    syntax = Forward()
    aggregate_initializer = Forward()
    local_decl = Forward()
    list_type = Forward()
    index = Forward()
    case_stmt = Forward()
    inverse_clause = Forward().setParseAction(lambda t: AttributeList('inverse', t))
    simple_types = Forward()
    stmt = Forward()
    remark = Forward()
    schema_body = Forward()
    simple_factor = Forward()
    constant_body = Forward()
    increment_control = Forward()
    domain_rule = Forward()
    entity_head = Forward()
    parameter = Forward()
    formal_parameter = Forward()
    element = Forward()
    where_clause = Forward()
    query_expression = Forward()
    precision_spec = Forward()
    until_control = Forward()
    repeat_control = Forward()
    local_variable = Forward()
    qualifier = Forward()
    general_aggregation_types = Forward().setParseAction(lambda t: AggregationType(t))
    while_control = Forward()
    term = Forward()
    derive_clause = Forward().setParseAction(lambda t: AttributeList('derive', t))
    actual_parameter_list = Forward()
    procedure_call_stmt = Forward()
    generalized_types = Forward()
    array_type = Forward()
    index_2 = Forward()
    index_1 = Forward()
    subtype_constraint_decl = Forward()
    one_of = Forward()
    primary = Forward()
    embedded_remark = Forward()
    instantiable_type = Forward()
    general_set_type = Forward()
    parameter_type = Forward()
    selector = Forward()
    aggregate_type = Forward()
    string_type = Forward()
    supertype_rule = Forward()
    increment = Forward()
    logical_expression = Forward()
    aggregate_source = Forward()
    interval_high = Forward()
    entity_decl = Forward().setParseAction(lambda t: EntityDeclaration(t))
    numeric_expression = Forward()
    entity_constructor = Forward()
    factor = Forward()
    rule_decl = Forward()
    subsuper = Forward()
    underlying_type = Forward().setParseAction(lambda t: UnderlyingType(t))
    case_label = Forward()
    procedure_head = Forward()
    compound_stmt = Forward()
    concrete_types = Forward()
    constant_decl = Forward()
    expression = Forward()
    real_type = Forward()
    width_spec = Forward()
    supertype_term = Forward()
    algorithm_head = Forward()
    bound_spec = Forward().setParseAction(lambda t: BoundSpecification(t))
    declaration = Forward()
    repetition = Forward()
    general_array_type = Forward()
    schema_decl = Forward()
    interval_item = Forward()
    bound_2 = Forward()
    bound_1 = Forward()
    function_head = Forward()
    repeat_stmt = Forward()
    entity_body = Forward()
    inverse_attr = Forward().setParseAction(lambda t: InverseAttribute(t))
    function_decl = Forward()
    supertype_expression = Forward()
    derived_attr = Forward().setParseAction(lambda t: DerivedAttribute(t))
    supertype_constraint = Forward()
    simple_expression = Forward()
    type_decl = Forward().setParseAction(lambda t: TypeDeclaration(t))
    binary_type = Forward().setParseAction(lambda t: BinaryType(t))
    if_stmt = Forward()
    return_stmt = Forward()
    function_call = Forward()
    index_qualifier = Forward()
    explicit_attr = Forward().setParseAction(lambda t: ExplicitAttribute(t))
    subtype_constraint = Forward()
    assignment_stmt = Forward()
    set_type = Forward()
    abstract_supertype_declaration = Forward()
    alias_stmt = Forward()
    width = Forward()
    interval_low = Forward()
    aggregation_types = Forward().setParseAction(lambda t: AggregationType(t))
    general_list_type = Forward()
    qualifiable_factor = Forward()
    subtype_constraint_body = Forward()
    supertype_factor = Forward()
    case_action = Forward()
    interval = Forward()
    procedure_decl << ((procedure_head + algorithm_head + ZeroOrMore(stmt) + END_PROCEDURE + CaselessLiteral(";")))
    bag_type << ((BAG + Optional(bound_spec) + OF + instantiable_type))
    general_bag_type << ((BAG + Optional(bound_spec) + OF + parameter_type))
    syntax << ((schema_decl + ZeroOrMore(schema_decl)))
    aggregate_initializer << ((CaselessLiteral("[") + Optional((element + ZeroOrMore((CaselessLiteral(",") + element)))) + CaselessLiteral("]")))
    local_decl << ((LOCAL + local_variable + ZeroOrMore(local_variable) + END_LOCAL + CaselessLiteral(";")))
    list_type << ((LIST + Optional(bound_spec) + OF + Optional(UNIQUE) + instantiable_type))
    index << (numeric_expression)
    case_stmt << ((CASE + selector + OF + ZeroOrMore(case_action) + Optional((OTHERWISE + CaselessLiteral(":") + stmt)) + END_CASE + CaselessLiteral(";")))
    inverse_clause << ((INVERSE + inverse_attr + ZeroOrMore(inverse_attr)))
    simple_types << ((binary_type | boolean_type | integer_type | logical_type | number_type | real_type | string_type))
    stmt << ((alias_stmt | assignment_stmt | case_stmt | compound_stmt | escape_stmt | if_stmt | null_stmt | procedure_call_stmt | repeat_stmt | return_stmt | skip_stmt))
    remark << ((embedded_remark | tail_remark))
    schema_body << ((ZeroOrMore(interface_specification) + Optional(constant_decl) + ZeroOrMore((declaration | rule_decl))))
    simple_factor << ((aggregate_initializer | interval | query_expression | (Optional(unary_op) + ((CaselessLiteral("(") + expression + CaselessLiteral(")")) | primary)) | entity_constructor | enumeration_reference))
    constant_body << ((constant_id + CaselessLiteral(":") + instantiable_type + CaselessLiteral(":=") + expression + CaselessLiteral(";")))
    increment_control << ((variable_id + CaselessLiteral(":=") + bound_1 + TO + bound_2 + Optional((BY + increment))))
    domain_rule << ((rule_label_id + CaselessLiteral(":") + expression))
    entity_head << ((ENTITY + entity_id + subsuper + CaselessLiteral(";")))
    parameter << (expression)
    formal_parameter << ((parameter_id + ZeroOrMore((CaselessLiteral(",") + parameter_id)) + CaselessLiteral(":") + parameter_type))
    element << ((expression + Optional((CaselessLiteral(":") + repetition))))
    where_clause << ((WHERE + domain_rule + CaselessLiteral(";") + ZeroOrMore((domain_rule + CaselessLiteral(";")))))
    query_expression << ((QUERY + CaselessLiteral("(") + variable_id + CaselessLiteral("<*") + aggregate_source + CaselessLiteral("|") + logical_expression + CaselessLiteral(")")))
    precision_spec << (numeric_expression)
    until_control << ((UNTIL + logical_expression))
    repeat_control << ((Optional(increment_control) + Optional(while_control) + Optional(until_control)))
    local_variable << ((variable_id + ZeroOrMore((CaselessLiteral(",") + variable_id)) + CaselessLiteral(":") + parameter_type + Optional((CaselessLiteral(":=") + expression)) + CaselessLiteral(";")))
    qualifier << ((attribute_qualifier | group_qualifier | index_qualifier))
    general_aggregation_types << ((general_array_type | general_bag_type | general_list_type | general_set_type))
    while_control << ((WHILE + logical_expression))
    term << ((factor + ZeroOrMore((multiplication_like_op + factor))))
    derive_clause << ((DERIVE + derived_attr + ZeroOrMore(derived_attr)))
    actual_parameter_list << ((CaselessLiteral("(") + Optional(parameter) + ZeroOrMore((CaselessLiteral(",") + parameter)) + CaselessLiteral(")")))
    procedure_call_stmt << (((built_in_procedure | procedure_ref) + actual_parameter_list + CaselessLiteral(";")))
    generalized_types << ((aggregate_type | general_aggregation_types | generic_entity_type | generic_type))
    array_type << ((ARRAY + bound_spec + OF + Optional(OPTIONAL) + Optional(UNIQUE) + instantiable_type))
    index_2 << (index)
    index_1 << (index)
    subtype_constraint_decl << ((subtype_constraint_head + subtype_constraint_body + END_SUBTYPE_CONSTRAINT + CaselessLiteral(";")))
    one_of << ((ONEOF + CaselessLiteral("(") + supertype_expression + ZeroOrMore((CaselessLiteral(",") + supertype_expression)) + CaselessLiteral(")")))
    primary << ((literal | (qualifiable_factor + ZeroOrMore(qualifier))))
    embedded_remark << ((CaselessLiteral("(*") + Optional(remark_tag) + ZeroOrMore(((not_paren_star + ZeroOrMore(not_paren_star)) | lparen_then_not_lparen_star | (CaselessLiteral("*") + ZeroOrMore(CaselessLiteral("*"))) | not_rparen_star_then_rparen | embedded_remark)) + CaselessLiteral("*)")))
    instantiable_type << ((concrete_types | entity_ref))
    general_set_type << ((SET + Optional(bound_spec) + OF + parameter_type))
    parameter_type << ((generalized_types | simple_types | named_types))
    selector << (expression)
    aggregate_type << ((AGGREGATE + Optional((CaselessLiteral(":") + type_label)) + OF + parameter_type))
    string_type << ((STRING + Optional(width_spec)))
    supertype_rule << ((SUPERTYPE + subtype_constraint))
    increment << (numeric_expression)
    logical_expression << (expression)
    aggregate_source << (simple_expression)
    interval_high << (simple_expression)
    entity_decl << ((entity_head + entity_body + END_ENTITY + CaselessLiteral(";")))
    numeric_expression << (simple_expression)
    entity_constructor << ((entity_ref + CaselessLiteral("(") + Optional((expression + ZeroOrMore((CaselessLiteral(",") + expression)))) + CaselessLiteral(")")))
    factor << ((simple_factor + Optional((CaselessLiteral("**") + simple_factor))))
    rule_decl << ((rule_head + algorithm_head + ZeroOrMore(stmt) + where_clause + END_RULE + CaselessLiteral(";")))
    subsuper << ((Optional(supertype_constraint) + Optional(subtype_declaration)))
    underlying_type << ((constructed_types | concrete_types))
    case_label << (expression)
    procedure_head << ((PROCEDURE + procedure_id + Optional((CaselessLiteral("(") + Optional(VAR) + formal_parameter + ZeroOrMore((CaselessLiteral(";") + Optional(VAR) + formal_parameter)) + CaselessLiteral(")"))) + CaselessLiteral(";")))
    compound_stmt << ((BEGIN + stmt + ZeroOrMore(stmt) + END + CaselessLiteral(";")))
    concrete_types << ((aggregation_types | simple_types | type_ref))
    constant_decl << ((CONSTANT + constant_body + ZeroOrMore(constant_body) + END_CONSTANT + CaselessLiteral(";")))
    expression << ((simple_expression + Optional((rel_op_extended + simple_expression))))
    real_type << ((REAL + Optional((CaselessLiteral("(") + precision_spec + CaselessLiteral(")")))))
    width_spec << ((CaselessLiteral("(") + width + CaselessLiteral(")") + Optional(FIXED)))
    supertype_term << ((one_of | (CaselessLiteral("(") + supertype_expression + CaselessLiteral(")")) | entity_ref))
    algorithm_head << ((ZeroOrMore(declaration) + Optional(constant_decl) + Optional(local_decl)))
    bound_spec << ((CaselessLiteral("[") + bound_1 + CaselessLiteral(":") + bound_2 + CaselessLiteral("]")))
    declaration << ((entity_decl | function_decl | procedure_decl | subtype_constraint_decl | type_decl))
    repetition << (numeric_expression)
    general_array_type << ((ARRAY + Optional(bound_spec) + OF + Optional(OPTIONAL) + Optional(UNIQUE) + parameter_type))
    schema_decl << ((SCHEMA + schema_id + Optional(schema_version_id) + CaselessLiteral(";") + schema_body + END_SCHEMA + CaselessLiteral(";")))
    interval_item << (simple_expression)
    bound_2 << (numeric_expression)
    bound_1 << (numeric_expression)
    function_head << ((FUNCTION + function_id + Optional((CaselessLiteral("(") + formal_parameter + ZeroOrMore((CaselessLiteral(";") + formal_parameter)) + CaselessLiteral(")"))) + CaselessLiteral(":") + parameter_type + CaselessLiteral(";")))
    repeat_stmt << ((REPEAT + repeat_control + CaselessLiteral(";") + stmt + ZeroOrMore(stmt) + END_REPEAT + CaselessLiteral(";")))
    entity_body << ((ZeroOrMore(explicit_attr) + Optional(derive_clause) + Optional(inverse_clause) + Optional(unique_clause) + Optional(where_clause)))
    inverse_attr << ((attribute_decl + CaselessLiteral(":") + Optional(((SET | BAG) + Optional(bound_spec) + OF)) + entity_ref + FOR + Optional((entity_ref + CaselessLiteral("."))) + attribute_ref + CaselessLiteral(";")))
    function_decl << ((function_head + algorithm_head + stmt + ZeroOrMore(stmt) + END_FUNCTION + CaselessLiteral(";")))
    supertype_expression << ((supertype_factor + ZeroOrMore((ANDOR + supertype_factor))))
    derived_attr << ((attribute_decl + CaselessLiteral(":") + parameter_type + CaselessLiteral(":=") + expression + CaselessLiteral(";")))
    supertype_constraint << ((abstract_supertype_declaration | abstract_entity_declaration | supertype_rule))
    simple_expression << ((term + ZeroOrMore((add_like_op + term))))
    type_decl << ((TYPE + type_id + CaselessLiteral("=") + underlying_type + CaselessLiteral(";") + Optional(where_clause) + END_TYPE + CaselessLiteral(";")))
    binary_type << ((BINARY + Optional(width_spec)))
    if_stmt << ((IF + logical_expression + THEN + stmt + ZeroOrMore(stmt) + Optional((ELSE + stmt + ZeroOrMore(stmt))) + END_IF + CaselessLiteral(";")))
    return_stmt << ((RETURN + Optional((CaselessLiteral("(") + expression + CaselessLiteral(")"))) + CaselessLiteral(";")))
    function_call << (((built_in_function | function_ref) + actual_parameter_list))
    index_qualifier << ((CaselessLiteral("[") + index_1 + Optional((CaselessLiteral(":") + index_2)) + CaselessLiteral("]")))
    explicit_attr << ((attribute_decl + ZeroOrMore((CaselessLiteral(",") + attribute_decl)) + CaselessLiteral(":") + Optional(OPTIONAL) + parameter_type + CaselessLiteral(";")))
    subtype_constraint << ((OF + CaselessLiteral("(") + supertype_expression + CaselessLiteral(")")))
    assignment_stmt << ((general_ref + ZeroOrMore(qualifier) + CaselessLiteral(":=") + expression + CaselessLiteral(";")))
    set_type << ((SET + Optional(bound_spec) + OF + instantiable_type))
    abstract_supertype_declaration << ((ABSTRACT + SUPERTYPE + Optional(subtype_constraint)))
    alias_stmt << ((ALIAS + variable_id + FOR + general_ref + ZeroOrMore(qualifier) + CaselessLiteral(";") + stmt + ZeroOrMore(stmt) + END_ALIAS + CaselessLiteral(";")))
    width << (numeric_expression)
    interval_low << (simple_expression)
    aggregation_types << ((array_type | bag_type | list_type | set_type))
    general_list_type << ((LIST + Optional(bound_spec) + OF + Optional(UNIQUE) + parameter_type))
    qualifiable_factor << ((function_call | attribute_ref | constant_factor | general_ref | population))
    subtype_constraint_body << ((Optional(abstract_supertype) + Optional(total_over) + Optional((supertype_expression + CaselessLiteral(";")))))
    supertype_factor << ((supertype_term + ZeroOrMore((AND + supertype_term))))
    case_action << ((case_label + ZeroOrMore((CaselessLiteral(",") + case_label)) + CaselessLiteral(":") + stmt))
    interval << ((CaselessLiteral("{") + interval_low + interval_op + interval_item + interval_op + interval_high + CaselessLiteral("}")))
    
    syntax.ignore(Regex(r"\((?:\*(?:[^*]*\*+)+?\))"))
    ast = syntax.parseFile(schema_fn)
    schema = schema.Schema(ast)

    with open(cache_file, "wb") as f:
        pickle.dump(schema, f, protocol=0)
